// Cocorico Restaurant Stock Management System
// Database Schema v2.0

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// AUTHENTICATION & USERS
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String
  role          UserRole  @default(USER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  stockMovements StockMovement[]
  sales          Sale[]

  @@index([email])
  @@map("users")
}

enum UserRole {
  ADMIN
  USER
}

// ============================================================================
// INVENTORY & PRODUCTS
// ============================================================================

model Product {
  id         String    @id @default(cuid())
  name       String
  quantity   Float     @default(0)
  unit       Unit      @default(PC)
  unitPrice  Float?
  totalValue Float?

  // Restaurant features
  trackable Boolean   @default(false)
  parLevel  Float?
  category  String?

  // Composite/Prepared product features
  isComposite Boolean @default(false) // If true, this product is made from other products
  yieldQuantity Float? // How much this recipe produces (e.g., 1 L of crème pâtissière)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  movements         StockMovement[]
  billProducts      BillProduct[]
  recipeIngredients RecipeIngredient[]
  disputeProducts   DisputeProduct[]
  dlcs              DLC[]

  // Composite product relations
  compositeIngredients CompositeIngredient[] @relation("CompositeProduct") // Ingredients needed to make this product
  usedInComposites     CompositeIngredient[] @relation("BaseIngredient")   // Composites that use this as ingredient

  @@index([name])
  @@index([category])
  @@index([isComposite])
  @@map("products")
}

enum Unit {
  // Weight
  KG    // Kilograms
  G     // Grams
  // Volume
  L     // Liters
  ML    // Milliliters
  CL    // Centiliters
  // Count
  PC    // Pieces
  BUNCH // Bunch (e.g., herbs)
  CLOVE // Clove (e.g., garlic)
}

// ============================================================================
// COMPOSITE/PREPARED PRODUCTS
// ============================================================================

model CompositeIngredient {
  id                String @id @default(cuid())
  compositeProductId String // The prepared product (e.g., crème pâtissière)
  baseProductId     String // The ingredient needed (e.g., milk)
  quantity          Float  // Amount needed
  unit              Unit   // Unit of measurement

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  compositeProduct Product @relation("CompositeProduct", fields: [compositeProductId], references: [id], onDelete: Cascade)
  baseProduct      Product @relation("BaseIngredient", fields: [baseProductId], references: [id], onDelete: Restrict)

  @@index([compositeProductId])
  @@index([baseProductId])
  @@map("composite_ingredients")
}

// ============================================================================
// STOCK MOVEMENTS (Event Sourcing)
// ============================================================================

model StockMovement {
  id           String       @id @default(cuid())
  productId    String
  movementType MovementType
  quantity     Float
  balanceAfter Float
  movementDate DateTime     @default(now())

  // References
  billId    String?
  disputeId String?
  userId    String?

  // Metadata
  reason      String
  description String?
  unitPrice   Float?
  totalValue  Float?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  product Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  bill    Bill?    @relation(fields: [billId], references: [id])
  dispute Dispute? @relation(fields: [disputeId], references: [id])
  user    User?    @relation(fields: [userId], references: [id])

  @@index([productId])
  @@index([movementDate])
  @@index([billId])
  @@map("stock_movements")
}

enum MovementType {
  IN
  OUT
  ADJUSTMENT
  INITIAL
}

// ============================================================================
// BILLS & DOCUMENTS
// ============================================================================

model Bill {
  id          String    @id @default(cuid())
  filename    String
  supplier    String?
  billDate    DateTime?
  totalAmount Float?
  rawContent  String?   @db.Text

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  products       BillProduct[]
  disputes       Dispute[]
  stockMovements StockMovement[]

  @@index([billDate])
  @@index([supplier])
  @@map("bills")
}

model BillProduct {
  id                  String @id @default(cuid())
  billId              String
  productId           String
  quantityExtracted   Float
  unitPriceExtracted  Float?
  totalValueExtracted Float?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  bill    Bill    @relation(fields: [billId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([billId, productId])
  @@index([billId])
  @@index([productId])
  @@map("bill_products")
}

// ============================================================================
// DISPUTES & RETURNS
// ============================================================================

model Dispute {
  id             String        @id @default(cuid())
  billId         String
  type           DisputeType
  status         DisputeStatus @default(OPEN)
  title          String
  description    String?       @db.Text
  amountDisputed Float?

  // Resolution
  resolvedAt      DateTime?
  resolutionNotes String?   @db.Text

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  bill           Bill              @relation(fields: [billId], references: [id], onDelete: Cascade)
  products       DisputeProduct[]
  stockMovements StockMovement[]

  @@index([billId])
  @@index([status])
  @@map("disputes")
}

enum DisputeType {
  RETURN
  COMPLAINT
  REFUND
}

enum DisputeStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

model DisputeProduct {
  id               String @id @default(cuid())
  disputeId        String
  productId        String
  reason           String
  quantityDisputed Float?
  description      String? @db.Text

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  dispute Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([disputeId])
  @@index([productId])
  @@map("dispute_products")
}

// ============================================================================
// MENU & RECIPES
// ============================================================================

model Dish {
  id          String  @id @default(cuid())
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)

  // Pricing
  sellingPrice Float? // Price sold to customers

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recipeIngredients RecipeIngredient[]
  sales             Sale[]
  menuDishes        MenuDish[]

  @@index([name])
  @@map("dishes")
}

model RecipeIngredient {
  id               String @id @default(cuid())
  dishId           String
  productId        String
  quantityRequired Float
  unit             String

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  dish    Dish    @relation(fields: [dishId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([dishId])
  @@index([productId])
  @@map("recipe_ingredients")
}

model Menu {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  startDate   DateTime?
  endDate     DateTime?
  isActive    Boolean  @default(true)

  // Pricing
  fixedPrice  Float?      // If set, menu has a fixed price
  pricingType PricingType @default(PRIX_FIXE) // Pricing model
  minCourses  Int?        // For CHOICE menus: minimum courses to select
  maxCourses  Int?        // For CHOICE menus: maximum courses to select

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sections MenuSection[]

  @@index([name])
  @@map("menus")
}

model MenuSection {
  id           String @id @default(cuid())
  menuId       String
  name         String
  displayOrder Int

  // Choice-based menu options
  isRequired Boolean @default(true)  // If false, customer can skip this section
  isOptional Boolean @default(false) // If true, section is optional in choice menus

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  menu  Menu       @relation(fields: [menuId], references: [id], onDelete: Cascade)
  dishes MenuDish[]

  @@index([menuId])
  @@map("menu_sections")
}

model MenuDish {
  id            String  @id @default(cuid())
  menuSectionId String
  dishId        String
  displayOrder  Int     @default(0)
  notes         String? @db.Text

  // Pricing
  priceOverride Float? // Override dish.sellingPrice for this specific menu

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  section MenuSection @relation(fields: [menuSectionId], references: [id], onDelete: Cascade)
  dish    Dish        @relation(fields: [dishId], references: [id], onDelete: Cascade)

  @@index([menuSectionId])
  @@index([dishId])
  @@map("menu_dishes")
}

enum PricingType {
  PRIX_FIXE  // Fixed price for the entire menu (all courses included)
  CHOICE     // Fixed price where customer chooses X courses from Y options
}

// ============================================================================
// SALES TRACKING
// ============================================================================

model Sale {
  id           String   @id @default(cuid())
  dishId       String
  quantitySold Int
  saleDate     DateTime @default(now())
  notes        String?  @db.Text
  userId       String?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  dish Dish  @relation(fields: [dishId], references: [id], onDelete: Restrict)
  user User? @relation(fields: [userId], references: [id])

  @@index([dishId])
  @@index([saleDate])
  @@index([userId])
  @@map("sales")
}

// ============================================================================
// DLC (Date Limite de Consommation) TRACKING
// ============================================================================

model DLC {
  id              String   @id @default(cuid())
  productId       String
  expirationDate  DateTime
  quantity        Float
  unit            Unit     @default(PC)
  batchNumber     String?
  supplier        String?
  status          DLCStatus @default(ACTIVE)

  // OCR metadata
  imageFilename   String?
  ocrRawData      String?  @db.Text

  // Notes
  notes           String?  @db.Text

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([expirationDate])
  @@index([status])
  @@map("dlcs")
}

enum DLCStatus {
  ACTIVE      // Product is still consumable
  CONSUMED    // Product has been used
  EXPIRED     // Product has passed expiration date
  DISCARDED   // Product was thrown away
}
